import { template } from "lodash";

export default template(`
// Code generated by @open-rpc/client-generator DO NOT EDIT.
import jayson from "jayson/lib/client/browser";
import ajv from "ajv";
import _ from "lodash";
import { OpenRPC, MethodObject, ContentDescriptorObject } from "@open-rpc/meta-schema";
import { MethodCallValidator } from "@open-rpc/schema-utils-js";
const callServer = (request, callback) => {
    const options = {
      method: 'POST',
      body: request,
      headers: {
        'Content-Type': 'application/json',
      }
    };
  
    fetch('http://localhost:8002', options)
      .then(function(res) { return res.text(); })
      .then(function(text) { callback(null, text); })
      .catch(function(err) { callback(err); });
};

<%= methodTypings.getAllUniqueTypings("typescript") %>

export default class <%= className %> {
  public rpc: any;
  private validator: MethodCallValidator;
  private openrpcDocument: OpenRPC;

  constructor(options: any) {
    this.openrpcDocument = <%= JSON.stringify(openrpcDocument) %>;

    if (options.transport === undefined || options.transport.type === undefined) {
      throw new Error("Invalid constructor params");
    }
    this.rpc = jayson(callServer,options.transport);
    this.validator = new MethodCallValidator(this.openrpcDocument);
  }

  private request(methodName: string, params: any[]): Promise<any> {
    const methodObject = _.find(this.openrpcDocument.methods, ({name}) => name === methodName) as MethodObject;
    const openRpcMethodValidationErrors = this.validator.validate(methodName, params);
    if (openRpcMethodValidationErrors.length > 0) {
      return Promise.reject(openRpcMethodValidationErrors);
    }

    let rpcParams;
    if (methodObject.paramStructure && methodObject.paramStructure === "by-name") {
      rpcParams = _.zipObject(params, _.map(methodObject.params, "name"));
    } else {
      rpcParams = params;
    }
    const result: any = this.rpc.request(methodName, rpcParams);
    return result.then((r: any) => r.result);
  }

  <% openrpcDocument.methods.forEach((method) => { %>
  /**
   * <%= method.summary %>
   */
  <%= methodTypings.getFunctionSignature(method, "typescript") %> {
    return this.request("<%= method.name %>", Array.from(arguments));
  }
  <% }); %>
}
`);
